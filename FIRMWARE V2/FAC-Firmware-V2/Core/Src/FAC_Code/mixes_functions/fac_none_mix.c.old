/*
 * fac_none_mix.c
 *
 *  Created on: Aug 14, 2025
 *      Author: filippo-castellan
 */

#include <FAC_Code/mixes_functions/fac_none_mix.h.old>

static Nonemix noneMix;

/* STATIC FUNCTION PROTORYPES */
static void FAC_none_mix_SET_dead_zone(uint8_t deadzone);
static void FAC_none_mix_SET_motor_channel(uint8_t motorNumber, uint8_t channel);
static void FAC_none_mix_SET_servo_channel(uint8_t servoNumber, uint8_t channel);
static uint8_t FAC_none_mix_GET_motor_channel(uint8_t motorNumber);
static uint8_t FAC_none_mix_GET_servo_channel(uint8_t servoNumber);

/* FUNCTION DEFINITION */
/* ----------------------PRIVATE FUNCTIONS---------------------- */

static void FAC_none_mix_SET_dead_zone(uint8_t deadzone) {
	noneMix.dead_zone = deadzone;
}

static void FAC_none_mix_SET_motor_channel(uint8_t motorNumber, uint8_t channel) {
	if (motorNumber > MOTORS_NUMBER)
		return;	// this motor does not exist
	noneMix.motors_channels[motorNumber - 1] = channel;
}

static void FAC_none_mix_SET_servo_channel(uint8_t servoNumber, uint8_t channel) {
	if (servoNumber > SERVOS_NUMBER)
		return;	// this servo does not exist
	noneMix.servos_channels[servoNumber - 1] = channel;
}

static uint8_t FAC_none_mix_GET_motor_channel(uint8_t motorNumber) {
	if (motorNumber > MOTORS_NUMBER)
		return 0;	// this motor does not exist
	return noneMix.motors_channels[motorNumber - 1];
}

static uint8_t FAC_none_mix_GET_servo_channel(uint8_t servoNumber) {
	if (servoNumber > SERVOS_NUMBER)
		return 0;	// this servo does not exist
	return noneMix.servos_channels[servoNumber - 1];
}
/* ----------------------PUBBLIC FUNCTIONS---------------------- */
uint8_t FAC_none_mix_GET_dead_zone() {
	return noneMix.dead_zone;
}

/**
 * @biref	Update the motors/servos speeds/positions
 * @note	This function directly apply the settings on the motor/servos
 * @time	Max execution time: ~8.25ms
 */
void FAC_none_mix_update() {
	/* get receiver values */
	int16_t channels[8];
	for (int i = 1; i <= 8; i++) {
		channels[i - 1] = FAC_std_receiver_GET_channel(i);
	}

	/* center the value for motors */
	for (int i = 1; i < 8; i++) {	// run across all channel
		for (int j = 1; j <= MOTORS_NUMBER; j++) {	// run across all motors
			if (i == FAC_none_mix_GET_motor_channel(j)/*noneMix.motors_channels[j - 1]*/) {	// check if the motor is associated to this channel
				channels[i - 1] = (channels[i - 1] - (RECEIVER_CHANNEL_RESOLUTION - 1) / 2) * 2;// center the value of the channel if it is associated to a motor
				channels[i - 1] = FAC_mix_calculate_dead_zone(channels[i - 1], noneMix.dead_zone, -(RECEIVER_CHANNEL_RESOLUTION - 1), RECEIVER_CHANNEL_RESOLUTION - 1);	// calculate also the deadzone
				/* calculate the direction */
				uint8_t dir;
				if (channels[i - 1] > 0)
					dir = FORWARD;
				else
					dir = BACKWARD;
				/* set the new motor speed */
				FAC_motor_set_speed_direction(j, dir, abs(channels[i - 1]));
			}
		}
		for (int j = 1; j <= SERVOS_NUMBER; j++) {	// run across all servos
			if (i == FAC_none_mix_GET_servo_channel(j)/*noneMix.servos_channels[j - 1]*/) {	// check if the servo is associated to this channel
				channels[i-1] = FAC_mix_calculate_dead_zone(channels[i - 1], noneMix.dead_zone, 0, RECEIVER_CHANNEL_RESOLUTION - 1);// calculate deadzone
				/* set the new servo position */
				FAC_servo_set_position(j, channels[i - 1]);
			}
		}
	}
}

/*
 * @brief	  	The initialization used when no mixes are active
 * @IMPORTANT 	!! MUST BE CALLED IF NEW SETTINGS ARE LOADED !!
 * @note	 	Channels are connected following the initialization
 */
void FAC_none_mix_init(uint8_t deadzone, uint8_t m1Ch, uint8_t m2Ch, uint8_t m3Ch, uint8_t s1Ch, uint8_t s2Ch) {
	FAC_none_mix_SET_dead_zone(deadzone);
	FAC_none_mix_SET_motor_channel(1, m1Ch);
	FAC_none_mix_SET_motor_channel(2, m2Ch);
	FAC_none_mix_SET_motor_channel(3, m3Ch);

	FAC_none_mix_SET_servo_channel(1, s1Ch);
	FAC_none_mix_SET_servo_channel(2, s2Ch);
}
